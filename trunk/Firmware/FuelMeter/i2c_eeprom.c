#include "i2c_eeprom.h"

void eeInit(void)
{
    /*Настраиваем Генератор скорости связи*/
    TWBR = (F_CPU/slaveF_SCL - 16) / (2 * /* TWI_Prescaler= 4^TWPS */1);
    
	/*
	Если TWI работает в ведущем режиме, то значение TWBR должно быть не менее 10. 
	Если значение TWBR меньше 10, то ведущее устройство шины может генерировать 
	некорректные сигналы на линиях SDA и SCL во время передачи байта.
	*/
    if(TWBR < 10)
    {
		TWBR = 10;
	}

		/*
	Настройка предделителя в регистре статуса Блока управления.
	Очищаются биты TWPS0 и TWPS1 регистра статуса, устанавливая тем самым, значение предделителя = 1.
		*/
    TWSR &= (~(_TWPS0 | _TWPS1));
}

uint8_t eeWriteByte(uint16_t address, uint8_t data)
{
	/*****УСТАНАВЛИВАЕМ СВЯЗЬ С ВЕДОМЫМ********/
    do
    {
		//Инициализация Регистра управления шиной в Блоке управления
		/*Перед началом передачи данных необходимо сформировать т.н. условие начала. 
		В состоянии покоя линии SCL и SDA находятся на высоком уровне. 
		Ведущее устройство (Контроллер AVR в нашем примере), которое хочет начать передачу данных, 
		изменяет состояние линии SDA к низкому уровню. Это и есть условие начала передачи данных.*/
        
		/*
		а)Сброс флага прерывания TWINT (Флаг TWINT сбрасывается программно 
		путем записи в него логической 1) для разрешения начала новой передачи данных 
		б)Уст. бит условия СТАРТ
		в)Уст. бит разрешения работы TWI
		*/
        TWCR = _TWINT | _TWSTA | _TWEN;

		//Ждем, пока шина даст добро (возможно, линия пока еще занята, ждем)
		//TWINT бит устанавливается аппаратно, если TWI завершает текущее 
		//задание и ожидает реакции программы
        while(!(TWCR & _TWINT));

        /*Проверяем регистр статуса, а точнее биты TWS3-7,
        которые доступны только для чтения. Эти пять битов 
        отражают состояние шины. TWS2-0 "отсекаем" с помощью операции "И 	0xF8". Если TWS7-3 = 0x08, то СТАРТ был успешным.*/
        if((TWSR & 0xF8) != TW_START)
            return false;

	/*К шине I2C может быть подключено множество подчиненных устройств 
	(к примеру, много микросхем внешней памяти EEPROM). Для того, чтобы 
	все микросхемы и контроллер знали, от кого и кому передается информация, 
	в протоколе реализована Адресация ведомых устройств. В каждой микросхеме, 
	предназначенной для работы с I2C, на заводе "зашит" определенный адрес. 
	Мы этот адрес передаем по всей шине, т.е. всем ведомым. Каждый ведомый 
	получает этот адрес и смотрит, типа мой это или чужой. Если мой, то О КРУТО,
	 со мной хочет работать контроллер AVR. Так вот и происходит "рукопожатие" между ведущим и ведомым.*/

	/*Так вот, мы хотим работать с микросхемой памяти 24LC64, поэтому по шине 
	нам надо передать ее адрес. Она узнает свой адрес, и будет знать, что данные
	 на запись адресуются именно ей. А остальные микросхемы, если они есть,
	 эти данные будут просто игнорировать.*/

	/*Постоянная часть адреса 24LC64 - 1010 (см. даташит на 24XX64), 
	3 бита - переменные (если вдруг мы захотим подключить несколько 
	одинаковых микросхем c одинаковыми заводскими адресами, они пригодятся; 
	в ином(нашем) случае выставляем нули), далее бит 0 - если хотим записывать 
	в память или 1 - если читаем данные из памяти I2C EEPROM*/
        
	//TWDR = 0b1010'000'0;    
        TWDR = (slaveAddressConst << 4) + (slaveAddressVar << 1) + (WRITEFLAG);

		/*Говорим регистру управления, что мы хотим передать данные, содержащиеся в регистре данных TWDR*/
        TWCR = _TWINT | _TWEN;

        //Ждем окончания передачи данных
        while(!(TWCR & _TWINT));
    
	/*Если нет подтверждения от ведомого, делаем все по-новой 
	(либо неполадки с линией, либо ведомого с таким адресом нет).
	Если же подтверждение поступило, то регистр статуса установит 
	биты в 0x18=TW_MT_SLA_ACK (в случае записи) или 0x40=TW_MR_SLA_ACK (в случае чтения).
	Грубо говоря, если TW_MT_SLA_ACK, то ведомый "говорит" нам, 
	что его адрес как раз 1010'000 и он готов для записи (чтения, если TW_MR_SLA_ACK).*/
    }while((TWSR & 0xF8) != TW_MT_SLA_ACK);
        
	/*Здесь можем уже уверенно говорить, что ведущий и ведомый 
	друг друга видят и понимают. Вначале скажем нашей микросхеме памяти, 
	по какому адресу мы хотим записать байт данных*/
    

	/*****ПЕРЕДАЕМ АДРЕС ЗАПИСИ********/
    
	/*Записываем в регистр данных старший разряд адреса (адрес 16-битный, uint16_t))..*/
    TWDR = (address >> 8);

    //..и передаем его
    TWCR = _TWINT | _TWEN;

    //ждем окончания передачи
    while(!(TWCR & _TWINT));

	/*Проверяем регистр статуса, принял ли ведомый данные. Если ведомый данные принял, 
	то он передает "Подтверждение", устанавливая SDA в низкий уровень. Блок управления, 
	в свою очередь, принимает подтверждение, и записывает в регистр статуса 0x28= TW_MT_DATA_ACK. 
	В противном случае 0x30= TW_MT_DATA_NACK */
    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
        return false;

    //Далее тоже самое для младшего разряда адреса
    TWDR = (address);
    TWCR = _TWINT | _TWEN;
    while(!(TWCR & _TWINT));

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
        return false;


	/*****ЗАПИСЫВАЕМ БАЙТ ДАННЫХ********/

    //Аналогично, как и передавали адрес, передаем байт данных
    TWDR = (data);
    TWCR = _TWINT | _TWEN;
    while(!(TWCR & _TWINT));

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
        return false;

    /*Устанавливаем условие завершения передачи данных (СТОП)
    (Устанавливаем бит условия СТОП)*/
    TWCR = _TWINT | _TWEN | _TWSTO;
    
    //Ждем установки условия СТОП
    while(TWCR & _TWSTO);

    return true;
}

uint8_t eeReadByte(uint16_t address)
{
    uint8_t data; //Переменная, в которую запишем прочитанный байт

	//Точно такой же кусок кода, как и в eeWriteByte...
	/*****УСТАНАВЛИВАЕМ СВЯЗЬ С ВЕДОМЫМ********/
    do
    {
        TWCR=_TWINT | _TWSTA | _TWEN;
        while(!(TWCR & _TWINT));

        if((TWSR & 0xF8) != TW_START)
            return false;

        TWDR = (slaveAddressConst << 4) + (slaveAddressVar << 1) + WRITEFLAG;        
        TWCR = _TWINT | _TWEN;

        while(!(TWCR & _TWINT));
    
    }while((TWSR & 0xF8) != TW_MT_SLA_ACK);
        

	/*****ПЕРЕДАЕМ АДРЕС ЧТЕНИЯ********/
    TWDR = (address >> 8);
    TWCR = _TWINT | _TWEN;
   while(!(TWCR & _TWINT));

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
        return false;

    TWDR = (address);
    TWCR = _TWINT | _TWEN;
    while(!(TWCR & _TWINT));

    if((TWSR & 0xF8) != TW_MT_DATA_ACK)
        return false;


	/*****ПЕРЕХОД В РЕЖИМ ЧТЕНИЯ********/
	/*Необходимо опять "связаться" с ведомым, т.к. ранее мы отсылали 
	адресный пакет (slaveAddressConst<<4) + (slaveAddressVar<<1) + WRITEFLAG, 
	чтобы записать адрес чтения байта данных. А теперь нужно перейти в режим чтения 
	(мы же хотим прочитать байт данных), для этого отсылаем новый пакет 
	(slaveAddressConst<<4) + (slaveAddressVar<<1) + READFLAG.*/
    
    //Повтор условия начала передачи
    TWCR = _TWINT | _TWSTA | _TWEN;
	//ждем выполнения текущей операции
    while(!(TWCR & _TWINT));

	/*Проверяем статус. Условие повтора начала передачи (0x10=TW_REP_START) должно подтвердиться*/
    if((TWSR & 0xF8) != TW_REP_START)
        return false;

    /*Записываем адрес ведомого (7 битов) и в конце бит чтения (1)*/
    //TWDR=0b1010'000'1;    
    TWDR = (slaveAddressConst << 4) + (slaveAddressVar << 1) + READFLAG;        

	//Отправляем..
    TWCR = _TWINT | _TWEN;
    while(!(TWCR & _TWINT));

	/*Проверяем, нашелся ли ведомый с адресом 1010'000 и готов ли он работать на чтение*/
    if((TWSR & 0xF8) != TW_MR_SLA_ACK)
        return false;


	/*****СЧИТЫВАЕМ БАЙТ ДАННЫХ********/

	/*Начинаем прием данных с помощью очистки флага прерывания TWINT. 
	Читаемый байт записывается в регистр TWDR.*/
    TWCR = _TWINT | _TWEN;

    //Ждем окончания приема..
    while(!(TWCR & _TWINT));

	/*Проверяем статус. По протоколу, прием данных должен оканчиваться без 
	подтверждения со стороны ведущего (TW_MR_DATA_NACK = 0x58)*/
    if((TWSR & 0xF8) != TW_MR_DATA_NACK)
        return false;

    /*Присваиваем переменной data значение, считанное в регистр данных TWDR*/
    data = TWDR;

    /*Устанавливаем условие завершения передачи данных (СТОП)*/
    TWCR = _TWINT | _TWEN | _TWSTO;
    
    //Ждем установки условия СТОП
    while(TWCR & _TWSTO);

    //Возвращаем считанный байт
    return data;
}
