#include "i2c_eeprom.h"

inline uint8_t eeConnect(uint16_t address)
{
	/*****УСТАНАВЛИВАЕМ СВЯЗЬ С ВЕДОМЫМ********/
    do
    {
		//Инициализация Регистра управления шиной в Блоке управления
		/*Перед началом передачи данных необходимо сформировать т.н. условие начала. 
		В состоянии покоя линии SCL и SDA находятся на высоком уровне. 
		Ведущее устройство (Контроллер AVR в нашем примере), которое хочет начать передачу данных, 
		изменяет состояние линии SDA к низкому уровню. Это и есть условие начала передачи данных.*/
        
		/*
		а)Сброс флага прерывания TWINT (Флаг TWINT сбрасывается программно 
		путем записи в него логической 1) для разрешения начала новой передачи данных 
		б)Уст. бит условия СТАРТ
		в)Уст. бит разрешения работы TWI
		*/
        TWCR = _TWINT | _TWSTA | _TWEN;

		//Ждем, пока шина даст добро (возможно, линия пока еще занята, ждем)
		//TWINT бит устанавливается аппаратно, если TWI завершает текущее 
		//задание и ожидает реакции программы
        //while(!(TWCR & _TWINT));
		WAIT_TRANSMIT;

        /*Проверяем регистр статуса, а точнее биты TWS3-7,
        которые доступны только для чтения. Эти пять битов 
        отражают состояние шины. TWS2-0 "отсекаем" с помощью операции "И 	0xF8". Если TWS7-3 = 0x08, то СТАРТ был успешным.*/
        if(TW_STATUS != TW_START)
		{
            return FALSE;
		}

		/*К шине I2C может быть подключено множество подчиненных устройств 
		(к примеру, много микросхем внешней памяти EEPROM). Для того, чтобы 
		все микросхемы и контроллер знали, от кого и кому передается информация, 
		в протоколе реализована Адресация ведомых устройств. В каждой микросхеме, 
		предназначенной для работы с I2C, на заводе "зашит" определенный адрес. 
		Мы этот адрес передаем по всей шине, т.е. всем ведомым. Каждый ведомый 
		получает этот адрес и смотрит, типа мой это или чужой. Если мой, то О КРУТО,
		 со мной хочет работать контроллер AVR. Так вот и происходит "рукопожатие" между ведущим и ведомым.*/

		/*Так вот, мы хотим работать с микросхемой памяти 24LC64, поэтому по шине 
		нам надо передать ее адрес. Она узнает свой адрес, и будет знать, что данные
		 на запись адресуются именно ей. А остальные микросхемы, если они есть,
		 эти данные будут просто игнорировать.*/

		/*Постоянная часть адреса 24LC64 - 1010 (см. даташит на 24XX64), 
		3 бита - переменные (если вдруг мы захотим подключить несколько 
		одинаковых микросхем c одинаковыми заводскими адресами, они пригодятся; 
		в ином(нашем) случае выставляем нули), далее бит 0 - если хотим записывать 
		в память или 1 - если читаем данные из памяти I2C EEPROM*/
        
		//TWDR = 0b1010'000'0;    
        TWDR = (slaveAddressConst << 4) + (slaveAddressVar << 1) + (TW_WRITE);

		/*Говорим регистру управления, что мы хотим передать данные, содержащиеся в регистре данных TWDR*/
        TWCR = _TWINT | _TWEN;

        //Ждем окончания передачи данных
        //while(!(TWCR & _TWINT));
		WAIT_TRANSMIT;
    
	/*Если нет подтверждения от ведомого, делаем все по-новой 
	(либо неполадки с линией, либо ведомого с таким адресом нет).
	Если же подтверждение поступило, то регистр статуса установит 
	биты в 0x18=TW_MT_SLA_ACK (в случае записи) или 0x40=TW_MR_SLA_ACK (в случае чтения).
	Грубо говоря, если TW_MT_SLA_ACK, то ведомый "говорит" нам, 
	что его адрес как раз 1010'000 и он готов для записи (чтения, если TW_MR_SLA_ACK).*/
    }while(TW_STATUS != TW_MT_SLA_ACK);
        
	/*Здесь можем уже уверенно говорить, что ведущий и ведомый 
	друг друга видят и понимают. Вначале скажем нашей микросхеме памяти, 
	по какому адресу мы хотим записать байт данных*/
    

	/*****ПЕРЕДАЕМ АДРЕС ЗАПИСИ********/
    
	/*Записываем в регистр данных старший разряд адреса (адрес 16-битный, uint16_t))..*/
    TWDR = (address >> 8);
    //..и передаем его
    TWCR = _TWINT | _TWEN;
    //ждем окончания передачи
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

	/*Проверяем регистр статуса, принял ли ведомый данные. Если ведомый данные принял, 
	то он передает "Подтверждение", устанавливая SDA в низкий уровень. Блок управления, 
	в свою очередь, принимает подтверждение, и записывает в регистр статуса 0x28= TW_MT_DATA_ACK. 
	В противном случае 0x30= TW_MT_DATA_NACK */
    if(TW_STATUS != TW_MT_DATA_ACK)
	{
        return FALSE;
	}

    //Далее тоже самое для младшего разряда адреса
    TWDR = (address);
    TWCR = _TWINT | _TWEN;
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

    if(TW_STATUS != TW_MT_DATA_ACK)
	{
        return FALSE;
	}
	return TRUE;
}

inline void eeStop(void)
{
	/*Устанавливаем условие завершения передачи данных (СТОП)(Устанавливаем бит условия СТОП)*/
	TWCR = _TWINT | _TWEN | _TWSTO;
	
	//Ждем установки условия СТОП
	while(TWCR & _TWSTO);
}

void eeInit(void)
{
    /*Настраиваем Генератор скорости связи*/
    TWBR = ((F_CPU / slaveF_SCL - 16) >> 1) / 4;//(2 * /* TWI_Prescaler= 4^TWPS */1);
    
	/*
	Если TWI работает в ведущем режиме, то значение TWBR должно быть не менее 10. 
	Если значение TWBR меньше 10, то ведущее устройство шины может генерировать 
	некорректные сигналы на линиях SDA и SCL во время передачи байта.
	*/
    if(TWBR < 10)
    {
		TWBR = 10;
	}

		/*
	Настройка предделителя в регистре статуса Блока управления.
	Очищаются биты TWPS0 и TWPS1 регистра статуса, устанавливая тем самым, значение предделителя = 1.
		*/
    TWSR &= (~(_TWPS0 | _TWPS1));
}

bool eeWriteByte(uint16_t address, uint8_t data)
{
	if(!eeConnect(address))
	{
		return FALSE;
	}
	
    TWDR = data;
    TWCR = _TWINT | _TWEN;
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

    if(TW_STATUS != TW_MT_DATA_ACK)
	{
        return FALSE;
	}

	eeStop();

    return TRUE;
}

bool eeWriteBytes( uint16_t address, uint8_t* data, uint8_t length )
{
	if(!eeConnect(address))
	{
		return FALSE;
	}
	
	for (uint8_t i = 0; i < length; i++)
	{
		TWDR = data[i];
		TWCR = _TWINT | _TWEN;
		//while(!(TWCR & _TWINT));
		WAIT_TRANSMIT;

		if(TW_STATUS != TW_MT_DATA_ACK)
		{
			return FALSE;
		}
	}

	eeStop();

	return TRUE;
}

bool eeReadByte(uint16_t address, uint8_t* data)
{
	if(!eeConnect(address))
	{
		return FALSE;
	}

	/*****ПЕРЕХОД В РЕЖИМ ЧТЕНИЯ********/
	/*Необходимо опять "связаться" с ведомым, т.к. ранее мы отсылали 
	адресный пакет (slaveAddressConst<<4) + (slaveAddressVar<<1) + WRITEFLAG, 
	чтобы записать адрес чтения байта данных. А теперь нужно перейти в режим чтения 
	(мы же хотим прочитать байт данных), для этого отсылаем новый пакет 
	(slaveAddressConst<<4) + (slaveAddressVar<<1) + READFLAG.*/
    
    //Повтор условия начала передачи
    TWCR = _TWINT | _TWSTA | _TWEN;
	//ждем выполнения текущей операции
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

	/*Проверяем статус. Условие повтора начала передачи (0x10=TW_REP_START) должно подтвердиться*/
    if(TW_STATUS != TW_REP_START)
	{
        return FALSE;
	}

    /*Записываем адрес ведомого (7 битов) и в конце бит чтения (1)*/
    //TWDR=0b1010'000'1;    
    TWDR = (slaveAddressConst << 4) + (slaveAddressVar << 1) + TW_READ;        

	//Отправляем..
    TWCR = _TWINT | _TWEN;
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

	/*Проверяем, нашелся ли ведомый с адресом 1010'000 и готов ли он работать на чтение*/
    if(TW_STATUS != TW_MR_SLA_ACK)
	{
        return FALSE;
	}

	/*****СЧИТЫВАЕМ БАЙТ ДАННЫХ********/

	/*Начинаем прием данных с помощью очистки флага прерывания TWINT. 
	Читаемый байт записывается в регистр TWDR.*/
    TWCR = _TWINT | _TWEN;

    //Ждем окончания приема..
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

	/*Проверяем статус. По протоколу, прием данных должен оканчиваться без 
	подтверждения со стороны ведущего (TW_MR_DATA_NACK = 0x58)*/
    if(TW_STATUS != TW_MR_DATA_NACK)
	{
        return FALSE;
	}

	eeStop();

    //Возвращаем считанный байт
	*data = TWDR;
    return TRUE;
}

bool eeReadBytes( uint16_t address, uint8_t* data, uint8_t length )
{
	if(!eeConnect(address))
	{
		return FALSE;
	}

	/*****ПЕРЕХОД В РЕЖИМ ЧТЕНИЯ********/
	/*Необходимо опять "связаться" с ведомым, т.к. ранее мы отсылали 
	адресный пакет (slaveAddressConst<<4) + (slaveAddressVar<<1) + WRITEFLAG, 
	чтобы записать адрес чтения байта данных. А теперь нужно перейти в режим чтения 
	(мы же хотим прочитать байт данных), для этого отсылаем новый пакет 
	(slaveAddressConst<<4) + (slaveAddressVar<<1) + READFLAG.*/
    
    //Повтор условия начала передачи
    TWCR = _TWINT | _TWSTA | _TWEN;
	//ждем выполнения текущей операции
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

	/*Проверяем статус. Условие повтора начала передачи (0x10=TW_REP_START) должно подтвердиться*/
    if(TW_STATUS != TW_REP_START)
	{
        return FALSE;
	}

    /*Записываем адрес ведомого (7 битов) и в конце бит чтения (1)*/
    //TWDR=0b1010'000'1;    
    TWDR = (slaveAddressConst << 4) + (slaveAddressVar << 1) + TW_READ;        

	//Отправляем..
    TWCR = _TWINT | _TWEN;
    //while(!(TWCR & _TWINT));
	WAIT_TRANSMIT;

	/*Проверяем, нашелся ли ведомый с адресом 1010'000 и готов ли он работать на чтение*/
    if(TW_STATUS != TW_MR_SLA_ACK)
	{
        return FALSE;
	}
	
	for (uint8_t i = 0; i < length; i++)
	{
		/*****СЧИТЫВАЕМ БАЙТ ДАННЫХ********/

		if (i == length - 1)
		{
			TWCR = _TWINT | _TWEN;
		} 
		else
		{
			TWCR = _TWINT | _TWEN | _TWEA;
		}

		//Ждем окончания приема..
		//while(!(TWCR & _TWINT));
		WAIT_TRANSMIT;

		if(TW_STATUS != ((i == length - 1) ? TW_MR_DATA_NACK : TW_MR_DATA_ACK))
		{
			return FALSE;
		}

		//сохраняем считанный байт
		data[i] = TWDR;
	}

	eeStop();

    return TRUE;
}
